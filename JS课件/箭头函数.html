<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>箭头函数、模板字符串</title>
</head>

<body>
    <div class="box"></div>
</body>
<script>
    // 之前定义函数的方式：
    // function 函数名(){}
    // var fun = function(){}
    // var fn = new Function()
    // 1. ES6新增语法——箭头函数
    // ES6新增的定义函数的方式
    // () => {} // 小括号放置形参
    // 通常我们将箭头函数赋值给一个变量，变量名字就是函数名字，通过变量名字调用函数就可以了
    // const fn = () => {}
    // 箭头函数是用来简化函数定义语法的
    // const fn = () => {
    //     console.log(123);
    // };
    // fn();
    // const fn = () => console.log(123);
    // fn()
    // 特点：
    // (1) 在箭头函数中，函数体只有一句代码，且代码的执行结果就是返回值，函数体大括号是可以省略的
    // 需求：现在定义一个函数接收两个数值作为参数，在函数体内要返回两个参数相加的结果
    // 传统写法：
    // function sum(num1, num2) {
    //     return (num1 + num2);
    // }
    // console.log(sum(1, 2))
    // 箭头函数写法：
    // const sum = (num1,num2) => {
    //     return num1 + num2
    // }
    // const sum = (x, y) => x + y;
    // const result = sum(1,2);
    // console.log(result);
    // (2) 如果形参只有一个，可以省略小括号
    // 需求：现在要定义一个函数，这个函数接收一个任意参数，在函数体当中在将参数进行返回
    // 传统写法：
    // function fn(v){
    //     return v;
    // }
    // 箭头函数写法：
    // 由于形参只有一个，形参小括号可以省略最终就是以下的写法：
    // const fn1 = (v) => {
    //     alert(v);
    // }
    // fn1(20);
    //    const fn1 = v => alert(v);
    //    const fn1 = v => v;
    //    const aa11 = fn1(20);
    //    console.log(aa11);

    // 2. 箭头函数 this 
    // 箭头函数不绑定 this 关键字，箭头函数中的 this 指向的是 函数定义位置的 this ，也就是说箭头函数定义在哪 this就指向那
    // function fn() {
    //     console.log(this);
    //     return () => {
    //         console.log(this)
    //     }
    // }
    // // console.log(fn())
    // const obj = { name: '张三' };
    // const resFn = fn.call(obj); // 通过变量接收函数
    // resFn();// 调用查看

    // 箭头函数面试题
    // var age = 100;
    // var obj1 = {
    //     age: 20,
    //     say: () => {
    //         alert(this.age);
    //     }
    // }
    // obj1.say();

    // 箭头函数没有自己的 this ，箭头函数当中的this 指向箭头函数定义区域的 this ，当前的 this 定义在obj这个对象里面，但是要注意 obj它是一个对象，它能产生作用域吗，肯定不能，那这个箭头函数实际被定义到了全局作用域下，所有在调用 say方法的时候，this指向的是 window,而在 window对象下面没有 age 属性,所以弹出的是undefined
    // 总结：这道题关键是对象是不能产生作用域的，say方法实际上是被定义在全局作用域下，say方法下的 this指向的是 window

    // 3. ES6的内置对象扩展——String的扩展方法
    // 3.1 模板字符串
    // ES6新增的创建字符串的方式，使用反引号定义
    // let name = `这是一个模板字符串`;
    // console.log(name);

    // 模板字符串的特点：
    // 1）模板字符串中可以解析变量
    // let name = `张三`;
    // let sayHi = `大哥你好啊！我叫${name},叫我三儿就行`;
    // console.log(sayHi);
    // // 2）模板字符串中可以换行
    // let result = {
    //     name : '嘚嘚以嘚嘚',
    //     age : 20
    // };
    // let html = `
    //     <div>
    //         <span>${result.name}</span>
    //         <span>${result.age}</span>
    //     </div>
    // `
    // var box = document.querySelector('.box');
    // box.innerHTML = html
    // console.log(html);
    // // 3）在模板字符串中可以调用函数
    // const fun = () => '嘚嘚一嘚嘚，造孽呀'
    // let html1 = `爱不爱他，我都是路人甲 ${fun()}`;
    // console.log(html1);
    // 鸡兔同笼，一共有34个头，96只脚，鸡有多少只，兔有多少只
    // for(let i = 0; i <= 34;i++){
    //     for(let j = 0; j <= 34-i;j++){
    //         if(i*2 + j*4 == 96 && i + j == 34){
    //             console.log(`鸡有${i}只，兔有${j}只`);
    //         }
    //     }
    // }
    // 一个庙里有100个和尚100桶水，一个大和尚一个人挑2桶，小和尚3个抬一桶，问大和尚小和尚各有多少


    // for(let i = 0; i <= 100;i++){
    //     for(let j = 0; j <= 100-i;j++){
    //         if(i + j == 100 && i*2 + j/3 == 100 && j%3 == 0){
    //             console.log(`大和尚${i}人，小和尚${j}个人`);
    //         }
    //     }
    // }

    // 4. set 和 map 数据结构
    // 4.1 Set
    // ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的，没有重复的值
    // Set本身是一个构造函数，用来生成Set数据结构
    // const s = new Set();
    // // // 添加数据     set有自己的添加方式，如果你要添加某一些值，你就可以这么添加
    // s.add(1);
    // s.add(2);
    // s.add(3).add(4).add(2);// 支持链式写法
    // // // // 成员的值都是唯一的 那如果我一直不断的在set里面添加数据，我们现阶段输出s，可以看下会输出什么？
    // console.log(s); // {}

    // 在此你会发现结果是1234，而且它的表现形式也和数组不太一样，数组是以中括号，我们刚说到的set是大括号，一切皆对象，而且我最后添加的2相当于替代掉了，原因是什么？
    // 原因就是它会去重，它成员的值都是唯一的
    // 问题：在这里它是以 == 去匹配的还是以 === 去匹配的，验证一下
    // 如果是 123 那它就是以 == 来匹配，如果是123'1''3'那就是 === 匹配
    // const set = new Set();
    // set.add(1);
    // set.add(2).add(3).add('1').add('3');
    // console.log(set); // {1,2,3,'1','3'}

    // 那这个set数据类型就这么麻烦非的一个一个添加吗？肯定还有另外一种数据的添加方式
    // 另一种定义数据方式：
    // let arr = [1, 2, 3, 1, 2, 3, 4];
    // let s2 = new Set(arr);
    // console.log(s2); // {1,2,3}

    // 问题：我们为什么要多加一种set数据结构呢，它到底解决了哪些问题
    // 那比如现在我们有一个面试题就是  去重
    // var a = [1, 2, 5, 23, 22, 1, 3, 22, 5, 23, 1];
    // 之前 ES5需要我们 for 循环遍历一个一个去重，现在我们通过set来处理，只需一行代码就可以了
    // 类型的转换
    // var s3 = new Set(a);
    // console.log(s3);   // 结果 {1,2,5,23,22,3}
    // 但是这个结果并非是我们想要的，我们要的是数组的形式，那接下来我们还需要把当前的set类型转换为数组
    // set类型转换为数组    当前有两种方式
    // 1） ES6提供的转换方式
    // console.log(Array.from(s3));

    // 2）扩展运算符转换
    // [...s3];
    // console.log([...s3])

    // 那再此重新整理
    // var a1 = [1, 2, 5, 2, 3, 1, 5]; // 即可输出数组
    // console.log([...new Set(a1)]);
    // var s4 = new Set(a1);
    // console.log([...s4]);


    // var s11 = new Set();

    // [2, 3, 5, 4, 5, 2, 2].forEach(value => s11.add(value)); // forEach 方法
    // for (let i of s11) {
    //     console.log(i);
    // }

    // var s22 = new Set([1, 2, 3, 4, 4]);
    // console.log([...s22]);   // [...] 扩展运算符方法
    // var s33 = new Set([1, 2, 3, 5, 4, 6, 5, 6]);
    // console.log(s33.size);// 去重之后的长度  size 这个方法


    // var s21 = new Set();
    // s21.add(1).add(2).add(3).add(1);
    // console.log(s21);

    // console.log(s21.has(4)); //  has 方法   查找   有返回true 没有返回 false

    // s21.delete(2); //    delete  方法 删除
    // console.log(s21);  // 1 3
    // console.log(s21.has(2));   // 返回  false

    // var s32 = new Set(['red', 'pink', 'yellow']);
    // for (let k of s32.keys()) {
    //     console.log(k);
    // } // keys()    得到的是值（键） 与value值相同

    // for (let v of s32.values()) {
    //     console.log(v);
    // }  // values()   得到的是值（键值）  与keys值相同
    // for (let k of s32.entries()) {
    //     console.log(k);
    // }  // entries()   返回一个新的Iterator对象，会按顺序插入到Set数组中
    // for (let x of s32) {
    //     console.log(x);
    // }


    // var a1 = new Set([1, 2, 3, 1, 5, 2]);
    // a1.forEach((v, k) => console.log(v * 2));
    // console.log(a1.clear());// clear()  方法清除集合

    // var aa = [1, 2, 2, 3, 1, 5, 5];
    // var bb = [...new Set(aa)];  // [1,2,3,5]
    // console.log(bb); // 去重 返回新数组

    // var cc = new Set([1, 2, 3]);
    // var dd = new Set([4, 2, 3]);
    // var ff = new Set([...cc, ...dd]);
    // console.log(ff); // 去重 合并数组

    // var aa1 = new Set([...cc].filter(x => !dd.has(x)));
    // console.log(aa1);// 差集 1
    // filter() 过滤器，把数组不同的过滤掉



    // 4.2 map
    // js 的对象，本质上是键值对的集合，但是传统上只能用字符串当作键，这给它的使用带来了很大的限制
    // 定义：ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作 键,Map键是有顺序的，Object键值只能手动计算或者for循环遍历
    // let m = new Map();
    // 那我们要在里面添加值，这里有一个专门设置set方法，这个set方法它目的是用来添加相关的值
    // m.set('id',1).set('name','小芳');
    // 这就相当于我们把结果直接添加到了map数据结构内部，所以这里也就是表示Map添加具体数据信息
    // console.log(m);

    // 除了键值对的形式，还可以定义其他的
    // var x = [1, 2, 3];
    // m.set(x, 100); // 这样我们可以把x当做键 的名字进行添加   这个也是它和对象不同的一个知识点，很重要
    // console.log(m);

    // 同样针对map也有另外一种方式
    // let m1 = new Map([['a', 1], ['b', 2], ['c', 3]]); // 相当于一个二维数组的信息
    // console.log(m1);
    // 那注意的一点就是在ES6里面添加了一个 for...of 的，目的就是循环遍历的
    // 在这里for...of可以遍历map、set，不能遍历的是我们的对象
    // for (let [k, v] of m1) {
    //     console.log(k);
    //     console.log(v);
    // }
    // 这样我们可以直接拿到m1里面的键和值

    // 之前set我们是不是可以转换类型，但是map和我们的对象类似，那这里的转换类型又是什么样的
    // 类型转换
    // 1) object 转换 map
    // var q1 = { name: 'q1', age: 20 }; // 转换为map数据结构
    // // 先定义一个map
    // var m2 = new Map();
    // // // 然后在进行一个循环遍历
    // for (let index in q1) {
    //     m2.set(index, q1[index]);
    // };
    // console.log(m2);

    // 2) map 转换 object
    // 先定义一个map
    // let m3 = new Map([['a', 1], ['b', 2], ['c', 3]]);
    // // // 再定义一个空的对象
    // let q2 = {};
    // for (let [k, v] of m3) {
    //     // 给对象q2添加值
    //     q2[k] = v; //  这里q2里面的 键 == v 这个值
    // }
    // console.log(q2);







</script>

</html>