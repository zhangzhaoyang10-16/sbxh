<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>动态组件 keep-alive的使用</title>
</head>

<body></body>
<script>
    // 1. 接下来演示一个小问题
    // 1. 比如在 Left 组件里面我希望实现一个点击按钮数值加一的效果  --> Left.vue
    // 2. 实现了 Left组件的加一功能之后，我们页面目前默认展示的 Left组件，那我们切换 Right组件在切换回去，会怎么样
    // 3. 是不是 Left组件我们刚才加1之后的数值变成了0 ，为什么勒，默认展示 Left组件对吧，但是当我们离开 Left组件之后切换到 Right组件，在点击 Left组件，那大家想我的两次切换是不是都叫 Left对吧，是同一个组件吗？是不是在你进行切换到 Right组件的时候，之前那个组件已经被销毁了，在切换回来的时候是不是重新创建渲染了一次 Left组件
    // 4. 那这里是不是证明了一件事，就是证明当我离开的时候会做一件什么样的事，会销毁被隐藏的那个组件，通过生命周期是不是还可以证明一下，我们监听创建阶段的 生命周期函数 created ,在内存创建好了对吧，然后再监听一个销毁阶段的生命周期函数 destroyed
    // 5. 刷新进来是不是 Left 组件又被创建，那我们点击按钮让 count+1 之后再切换到 Right 是不是有被销毁，在点击切换到 Left组件是不是又被创建了，重新初始化了一个 data对吧，和第一次默认出现的 Left有关系吗，是不是没有了，所以我们第二次看到的 Left组件是一个全新的组件，所以 数值会为 0，
    // 6.咱们动态组件在每一次发送组件切换的时候，被隐藏的组件都会被销毁，将要被展示出来的组件会被重新创建一个新的

    // 7. 那这个状态是不是有时候也是不对的啊，我希望我展示离开了之后再切换回去的时候，我的状态还在，也就是说我的数值不会被重新渲染，那这个时候怎么做了，是不是想办法在离开 Left 组件的时候，不要被销毁，怎么不被销毁，用我们内置的另外的一个标签 keep-alive

    // 2. 使用 keep-alive 保持状态
    // 使用方法：
    // 我们在这个 <component :is="comName"></component> 里面的组件会被动态的创建和销毁，那咱们就用 keep-alive包起来就可以了

    // 注意：keep-alive标签是 Vue 内置的，和 component 一样都是 vue 内置的标签，不需要自己去声明，直接可以进行使用

    // 需求：当我离开 Left 组件的时候 Left组件会被缓存，当我在进入 Left组件的时候它是不是又被激活了，那么我们有的时候在实际开发中，希望能够监听到这个组件被缓存了这么一个动作，或者它这个组件被激活的时候咱们希望做一件事，也就是说咱们希望监听到被缓存的那个时刻或者我们能够监听到被激活的那个时刻

    // 3. keep-alive 对应的生命周期函数
    // vue 提供了 keep-alive 对应的生命周期函数
    // 1. 当组件被缓存时，会自动触发组件的 deactivated 生命周期函数
    // 2. 当组件被激活时，会自动触发组件的 activated 生命周期函数
    // 注意：我们在讲生命周期的时候是不是没有讲这个，是因为默认是不可用的，只要在使用了 keep-alive 标签之后才能使用， --> Left.vue

    // 4. keep-alive 的 include 属性
    // 当前我们在使用 keep-alive 的时候没有指定说哪个组件 需要 被缓存 哪个 不需要 被缓存对吧，所以它就会默认会把所有包起来的组件都给咱们缓存，也就是说在 component 组件里面我们按需切换了两个组件，那这两个组件都会被缓存

    // 那么有的时候我们只希望 Left组件被缓存，不希望 Right 被缓存

    // 当我们有这样的需求的时候 ，keep-alive 给我们提供了 include 属性，那通过这个属性来告诉 keep-alive哪些组件是需要被缓存的，就放到 include 这个属性里面就可以了

    // include 属性用来指定：只有名称匹配的组件会被缓存，多个组件之间使用 英文的逗号分隔
    // <keep-alive include="MyLeft,MyRight">
    //     <component :is="comName"></component>
    // </keep-alive>

    // 扩展： exclude
    // include是包含项，exclude是排除项，这两个属性不能同时使用，那么我们使用 exclude 的话，是不是默认都是被缓存的，只有某一个组件是不被缓存的

    // 5. 了解组件注册名称和组件声明的 name 的区别
    // 在Left组件和 Right组件中有起 name 名称吗？是不是没有，那大家打开调试工具可以看到，我们的一个叫 Left,一个叫 Right,为什么是这两个名字，是不是因为我们在使用 这两个组件的时候导入，注册了这两个组件，注册名是 Left 和 Right

    // 1. 注意： 如果在 "声明组件" 的时候，也就是定义组件模板的时候，没有为组件指定 name 名称，则组件的名称默认就是 '注册时候的名称'
    // 2. 比如我现在给 Right 组件起一个 name 名字,大家可以看一下 我们在调试工具里面看到的是什么
    // 3. 当提供了 name 属性之后，组件的名称，就是 name 属性的值
    // 4. 大家来看我们在 App.vue里面的 keep-alive标签中是不是排除了 Right组件，那现在呢，在调试工具里面有被排除吗，是不是没有排除依然缓存了，为什么刚才可以使用，现在不能使用了
    // 5. 是不是之前我们没有给 Right 组件起自己的名字，所以它默认名称就是咱们的注册名称，但是现在对于 Right组件来说它是不是有自己的名称了，它不叫 Right,叫 MyRight,那我们应该排除的是 MyRight

    // 6. 所以说在实际开发中，我们可以通过 name 属性给每个组件都起一个自己的名称，在真正的项目开发中，大家注意，为了标准，使用起来更加的方便我们一般都会建议大家给自己创建的每一个组件都起一个 name 名称，因为这样的话看到这个名称 就知道我展示的是哪个组件，注册的名称只是为了给咱们在页面上用标签的方式使用，但是这个组件被使用了以后我们通过调试工具去看它的名字，那我们是不是应该看到的是 name 的名称啊，这个要区分开
</script>

</html>