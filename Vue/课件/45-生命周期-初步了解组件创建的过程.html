<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生命周期 初步了解组件创建的过程</title>
</head>
<body>
    
</body>
<script>
    // 接下来带大家详细的看一下每一个生命周期函数
    // 1. 生命周期图示：
    // 在这里我们结合vue官方文档，文档里面给出了“生命周期图示”，
        // https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram     生命周期图示网址

    // 2. 项目怎么跑起来的
        // webpack -->从 main.js开始打包  -->发现 main.js里面用到了 App.vue 这样就把App创建一个实例出来 -->  App.vue 里面又用到了 Left和Right组件，这两个里面又用到了 Count组件，就跟着树状的形式进行，然后我们这个 webpack就把整个树都给解析转换 最终编译成js代码

        // 会编译到两个js里面，而这两个js代码放到了首页里面去，那我们浏览器就会解析和执行这两个js里面的代码，把咱们所有的组件都给渲染到页面上
        // 那整个项目是不是从 main.js 里面开始进行的，而 main.js 是通过 webpack进行打包编译的

        // 详解生命周期图示：
            // 1. <MyCount></MyCount>开始，这个就代表 new 一个 vue实例，大家可以认为一用这个组件就相当于 new 了一个组件实例，现在是不是就进入了MyCount 组件的一个生命周期了
            // 2. 新建 Test.vue  ，模板结构写好之后是不是没有运行使用，是不是要进行使用，进入到 App.vue里面导入 Test.vue组件,之后在通过components进行注册组件，在div里面进行使用
            // 3. 现在是不是就使用到了 Test组件了，就证明咱们是不是创建出 Test组件的实例了，也就是说我们一使用就相当于new 了一个 vue实例

        // 2.1 生命周期-了解beforeCreate和created生命周期函数的特点
            // 详细生命周期图示：
                // 1. 创建好vue实例，立马进入第一个环节，在第一个环节要做一些事情，init是初始化，Events&Lifecycle是事件和生命周期函数，也就是说我们在页面上以标签的形式一使用Test组件就创建了实例，第一个要做的事情就是在内存里面，初始化这个组件对应的一些基本的事件还有一些生命周期函数，我们这些生命周期函数是不是在我们第一个环节就被初始化创建好了，图上绿色的矩形就是代表我们要做的一些事情，当这些事情做完以后就会立即触发生命周期函数

                // 2. beforeCreate 是不是在这个组件对应的事件和生命周期都被初始化好以后就触发了，那我们现在关心的是不是在这个 beforeCreate函数里面我们能做什么事对吧，在组件中props/data/methods都未创建，处于一个不可用的状态，不可调用props/data/methods，什么也做不了   --> Test.vue 进行演示    在此我们输出 init之后能够显示 你好，是不是就证明props是可用的

                // 3. 执行完beforeCreate之后就会立即进入下一个环节，第二个环节就是正在初始化 props/data/methods,当这个阶段结束之后会立即进入 created 生命周期函数，自动调用 created

                // 4. 在 created 里面 组件的 props/data/methods 已经创建好了 ，都处于一个可用的状态，也就是说在 created 里面是不是可以访问到 这些数据了，但是此时组件的模板结构尚未生成，也就是说 template 中的DOM结构还没有被渲染，只是这些数据可用了 --> Test.vue 进行演示    在此我们可以输出所有数据，也就证明 created 生命周期函数触发的时候，数据是可用的，这个阶段是非常重要的，在实际开发中会经常用到，在这个函数里面发起Ajax请求来拿到数据，当Ajax请求拿到数据以后要给谁用，是不是给页面的模板结构去渲染，渲染页面的数据是不是要从 data 里面拿，那咱们拿到 methods 中的数据是不是要挂到 data 里面去，也就是存到 data 里面去 --> Test.vue 进行演示   在methods 中定义一个方法 initBookList ，只要调用这个方法，咱们就可以发起请求了,我们写完initBookList方法只会不调用是不是不会发起请求拿到数据，在beforeCreate可以调用吗，是不是不能调用，在这个阶段是不是什么也干不了，最早只能在 created 里面调用    

                // 5. 现在有一个小需求：就是在  template 里面将图书列表给渲染到页面上    ,这里整个的过程就是我们在 data 里面定义一个空数组，渲染到页面之后是0本图书，当我们发起Ajax请求之后，发起成功返回数据之后将 result的 数据传给 books 的数组中，这样 books就不在是一个空的数组，那在页面中也就可以渲染到 有多少本图书了

                // 6. 注意点：方法和数据虽然都是可用的状态，但是组件的模板结构还没有被渲染到浏览器里面，在这个阶段组件的模板结构尚未生成，不能操作DOM   --> Test.vue  在 created 操作 DOM


        // 2.2 生命周期-了解beforeMount和 mounted 生命周期函数

            // 详细生命周期图示：
                // 1. 棱形是判断，这个棱形的地方和组件没有关系和我们vue 实例有关系    --> main.js
                    // 进入main.js 我们new 一个vue  构造函数的时候，我们是不是可以指定一个 el,当前我们是不是提供了，提供了走 YES，没有提供这个选项就走NO，走了YES它就会继续判断是否有 template 这个选项，我们不推荐使用，就走NO这个选项

                // 2. 刚才走的是判断有 指定 el 的选项，接下来我们走一次没有 el 选项，在 main.js中 将原来的内容改回来,现在没有 el了，我们走NO 这一条，有一句提示：当 vm.$mount(el)被调用的时候，去执行下面的判断，有template就执行左侧，没有执行右侧，我们不推荐使用就执行右侧，那左侧编译的是template这个选项，就是有 template就编译 template选项，没有template 就执行 el区域里面的 DOM结构，从判断到执行这个阶段简单来说就是基于 data 里面的数据和 定义的模板结构在内存中编译生成 HTML 对应的模板结构，那这个过程是有谁进行编译的   就是我们package.json 里面的包  ----  vue-template-compiler  ，这个包会帮助我们把数据和模板结合到一起得到最终的一个结构  ，总的来说这个阶段就是在编译我们的html结构，大家在这里能够看到我们 这个模板结构是我们最终的数据吗，不是吧，我们是不是把data,methods等数据都解析到一起，在渲染到页面，那这个我们是不是就把对应组件的结构就创建好了

                // 3. 记住是在内存里创建好的，当咱们在内存中把模板结构编译好之后，接着就自动调用第三个生命周期函数  beforeMount,调用了这个生命周期函数的时候，就是将要把内存中编译好的HTML结构，渲染到浏览器中，只是将要对吧，还没有渲染到浏览器，所以此时浏览器中还没有当前组件的DOM 结构，也就是说只是内存有了 DOM结构，页面中并没有    我们把刚才create中操作DOM这一项放到beforeMount里面--> Test.vue  进行演示   

                // 4. 在 beforeMount 操作DOM 返回 null  ,那就证明在页面中没有这个组件对应的 DOM 结构，也就是说在 beforeMount生命周期 里面我们是不是也不能操作 DOM 结构，所以在这个函数也没什么意义，但是我们能不能在 这个发起Ajax请求，就是不再 created发起请求了，而是在目前这个生命周期函数里发起，是不是也可以，因为最早只能在 created 里面发起，往后后延也是可以的是吧，但是我们发Ajax是不是越早越好，越早就越快速的拿到我们的数据，所以一般都在 created 里面发起Ajax请求

                // 5. 当 beforeMount 执行完以后是不是又接着执行下一个阶段，就是为当前的vm实例创建 $el属性 并且把 el 替换掉  ,我们在 beforeMount 里面执行输出 $el属性,返回 undefined，也就是说当前 beforeMount 没有这个属性，那么当 beforeMount 执行完之后就执行 mounted 生命周期函数了，我们在这个里面输出 $el 属性

                // 6. 返回一个 DOM 元素，也就是说我们在之前的条件执行完证明我们页面已经渲染好了，只要执行完浏览器中立马就有了这个组件的UI结构了，那么我们的DOM就可以被操作了，因此就会立即执行另外一个生命周期函数 mounted,代表已经把内存中的HTML结构，成功的渲染到了浏览器之中了，那既然成功渲染到了浏览者，那我们是不是就可以操作 DOM 了，在 Test.vue 验证一下   

                // 得出一个结论：就是说我们最早是不是只能在 mounted 这里操作 DOM ，其他阶段是不是不可用了，因为执行到 mounted 的时候是第一次把 DOM 渲染到浏览器里面，在这之前 DOM 结构是没有被渲染的，这也是一个非常重要的函数

                // 目前我们就学完了创建阶段的前四个函数


</script>
</html>