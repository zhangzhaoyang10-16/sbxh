<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ref-初步实现按钮和文本框的按需展示</title>
  </head>
  <body></body>
  <script>
    // 1.初步实现按钮和文本框的按需展示
    // 需求：现在我们输入框和按钮同时展示了，我们按需展示，也就是说我们接下来要做的就是有输入框的时候你看不到按钮，有按钮的时候你看不到输入框
    // 那我们是不是需要通过 v-if 来进行展示，现在我们可以定义一个布尔值，我们定义好了布尔值，那我们是不是需要通过这个值来控制到输入框和按钮的展示和隐藏,现在通过我们定义好的数据，false展示的是按钮，true展示的是输入框,那之后是不是就是点击按钮切换出输入框

    // 目前点击按钮是不是可以实现输入框展示，那么接下来我希望当输入框失去焦点的时候再次展示按钮

    // 那是不是我们绑定一个事件监听就可以了
    // 监听事件 @blur

    // 现在基本的功能就实现了，但是有一点大家有没有发现，当我们点击按钮展示输入框的时候，输入框有没有自动拿到焦点吗？是不是没有，还需要我们自己点一下对吧，那现在我们就需要想想怎么才能点击按钮让输入框自动获得焦点

    // 输入框自动获得焦点分析：
    // 1. 我们想要输入框获得焦点，是不是我们只要拿到输入框的 DOM 元素就可以调用 focus 方法了，让其自动获得焦点
    // 2. 首先我们怎么拿到这个 DOM 元素 是不是 ref属性就可以，先给这个输入框加一个 ref 引用,在这里建议大家以后起 ref 名字的时候都以 ref结尾，这样更方便我们看到这个名字就知道是一个 ref的引用名
    // 3. 接下来是不是我们要进行一个获得焦点了操作，那在那实现这部操作，实在点击按钮的方法里进行操作还是在失去焦点展示按钮方法上操作，很明显应该是在展示输入框的时候来获得焦点对吧，所以我们在 showInput 方法里面操作
    // 4. 报错了，报错信息：Cannot read properties of undefined (reading 'focus')  ，无法 读取 属性 focus 未定义，谁没有定义，是 focus吗
    // 5. 咱们在实际编程中，在前端领域中，大家会频繁遇到这个错误，但是总是有很多人都不懂这个错，这个的意思是我要调用一个 focus 方法，或者我要访问一个 focus 属性，但是它前面的东西是什么，是不是一个 undefined

    // 6.在 showInput方法里调用了一个 focus() 方法，那咱们说了这个方法前面的东西是一个 undefined，前面是不是 iptRef，也就是说 iptRef 是一个 undefined ，那大家想 undefined 那调用出任何属性和方法吗   我们输出一下 iptRef    返回 undefined

    // 7.为什么我们的 iptRef 值没有拿到？  大家来看如果我们没有执行到 this.inputVisible = true;这段代码 ，那我们页面展示的是什么，是不是按钮，没有输入框是不是拿不到它的  ref 引用，然后才执行的 this.inputVisible = true 这段代码，这段代码代表的是不是我们将要把文本框展示出来，这段代码执行完以后只是这个布尔值变成了 true对吧，但是页面是不是还没有来得及更新，页面看到的还是按钮对吧

    // 8. 看我们的生命周期里面的更新代码那一块，是不是当data 里面的数据发生变化才会触发 DOM元素的更新 ，那么大家来想一想，数据是新的，带上页面是不是没来得及更新，是不是还是旧的，this.inputVisible = true;这段代码是不是我们数据是最新的了，将要展示文本框了，但是是不是还没来得及展示

    // 9. 那我们执行完 this.inputVisible = true;这段代码是不是接着就执行下一段代码，那我们能拿到我们的 ref 引用吗，是不是拿不到，那我们现在知道为什么会报错，为什么是 undefined对吧，问题找到了，怎么解决

    // 10.现在是不是就是考虑 this.$refs.iptRef.focus()这段代码不报错，是不是要保证我们页面有这个元素，才可以不报错，那要想这段代码不报错，前提是这行代码调用应该放在我们代码更新以后，那怎么让这行代码执行往后延一下

    // 11.当什么时候页面渲染完毕了，this.$refs.iptRef.focus()它才能被执行 ，它应该延时到那一刻，是不是当页面重新渲染完毕之后，不需要考虑生命周期函数，vue  给我们提供了这么一个方法  this.$nextTick(cb)方法

    // 2. this.$nextTick(cb)方法
    // 这个方法是通过组件实例调用出来的，组件实例身上有这么一个官方挂载的方法,里面接收的是一个 cb，cb 是个回调，它代表把回调函数里面的代码延迟执行，延迟到当 DOM 重新被渲染完毕在去执行

    // 接着解决问题，就说什么时候执行 this.$refs.iptRef.focus()，是不是应该把这行代码调用，放到 cb回调函数里面就可以了

    // 当某些代码的执行，需要往后延迟，延迟到 DOM 重新渲染完毕以后在执行，这个时候就应该想的 this.$nextTick(cb)方法来实现需求

    // 结论：组件的 $nextTick(cb)方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行，通俗的理解是：等组件的 DOM 更新完成之后，再执行 cb回调函数，从而能保证 cb 回调函数可以操作到最新的 DOM 元素

    // 在这里，大家一定能够想到生命周期函数的 updated ,那想一下我们是在点击那个按钮的时候进行获取焦点，但是咱们 updated里面 只要data 里面数据变化了，必会触发 updated，所以写在 updated里面是不合适的，演示：  -->App.vue演示

    // 注意： updated生命周期函数和 methods 是平级，不可将 updated 放到 methods里面
  </script>
</html>
